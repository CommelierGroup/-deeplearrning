### Q1. python의 가상환경이 무엇인가요? 개념을 간략하게 설명해주세요.

A: 프로젝트마다 독립적인 Python 실행 환경을 제공하는 도구이다.
이를 통해 각 프로젝트마다 개별적인 패키지 버전과 설정을 가질 수 있다. 또한 프로젝트별로 서로 다른 Python 버전을 사용할 수 있다.


### Q2. python의 가상환경을 만드려면 어떤 명령어를 사용해야할까요? 이 파일은 git에 공유해야하나요?

A
```bash
python -m venv {가상환경 이름}
```
일반적으로 가상환경 폴더 자체는 git 에 포함시키지 않는다.
대신 실행에 필요한, 가상환경에서 설치한 패키지들을 기록한 파일을 Git 에 포함시킨다.
마치 node_modules 는 .gitignore 에 포함한 후, package.json 만 공유하듯


### Q3. python 내장명령어가 아닌 pyenv로도 환경변수를 설정할 수 있습니다. 둘의 차이가 무엇인가요?
A: Python 버전관리와 관련이 있다.
일반 python venv 명령어로 가상환경을 설정할 경우, 현재 시스템에 설치된 Python 버전을 그대로 사용하게 된다.
pyenv 를 통해 설정할 경우, 프로젝트별로 다른 Python 버전을 사용할 수 있도록 해준다.



### Q4. 다양한 개발자들과 협업하기 위해서는 의존성 관리를 해야합니다. 파이썬의 대표적인 의존성 관리 방법을 설명해주세요.

A
- 방법 1) requirement.txt
  - 기본 개념
    - 파이썬 프로젝트에서 사용하는 모든 패키지와 그 버전을 파일에 기록한다.
  - 장점
    - 매우 간단하고 가벼운 의존성 관리 방법
    - 별도의 도구 설치가 필요하지 않음
  - 단점
    - 패키지간 의존성 충돌에 한계가 있으며, 개발 환경과 프로덕션 환경의 의존성을 명확히 구분하기가 어렵다.
- 방법 2) pipenv
  - 기본 개념
    - pip 와 virtualenv 를 통합한 도구로, 의존성 관리와 가상환경 관리를 한 번에 처리할 수 있다.
  - 장점
    - 의존성과 가상환경을 동시에 관리할 수 있다.
    - Pipfile.lock 을 통해 의존성을 고정하여 패키지 버전 충돌을 방지할 수 있다.
    - 개발용과 프로덕션용 의존성을 쉽게 구분할 수 있다.
- 방법 3) Poetry
  - 기본 개념
    - pyproject.toml 을 사용하여 의존성을 관리한다.
    - 가상환경을 자동으로 생성/관리하며, 의존성 충돌을 방지하는 고급 기능을 제공한다.
    - 의존성 관리 외에도 패키지 배포 기능을 지원한다.
  - 장점
    - 의존성 관리와 패키지 배포를 모두 지원한다.
    - 직관적인 의존성 관리 및 의존성 충돌 해결 기능을 제공한다.
    - 개발, 테스트, 프로덕션 의존성을 명확하게 분리할 수 있다.
  - 단점
    - 상대적으로 requirements.txt 나 pipenv 보다 복잡하다.



### Q5. Poetry 방식으로 이 디렉토리를 초기화해주세요. 초기화하려면 어떻게 해야합니까?
A
1. Poetry 설치
```bash
curl -sSL https://install.python-poetry.org | python3 -
```
2. 프로젝트 초기화
```bash
poetry init
```
3. 패키지 설치(pyproject.toml 을 바탕으로)
```bash
poetry install
```
4. Poetry 쉘 활성화
```bash
poetry shell
```
5. 패키지 추가
```bash
poetry add {패키지명}
``` 


### Q6. Numpy 라이브러리를 설치한 이후 의존성을 명시해주세요. 의존성을 명시하려면 어떻게 해야합니까?

A
```bash
poetry add numpy
``` 
위 명령어를 사용하여 numpy 를 설치하면, poetry 에서 관리하는 pyproject.toml 과 poetry.lock 파일에 의존성이 기록된다.


### Q7. 아래와 같은 1차원 배열이 있습니다. 이를 2X3 형태의 2차원 배열로 변환해보세요.

```
np.array([1, 2, 3, 4, 5, 6])
```

A
```
np.array([1, 2, 3, 4, 5, 6]).reshape(2, 3)
```


### Q8. 아래와 같은 2차원 배열이 있습니다. 이 배열의 전체 합과 평균을 구하세요.

```
np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
```

A
```
np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]).sum()
np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]).mean()
```

### Q9. 아래와 같은 2차원 배열이 있습니다. 이 배열에서 최대값과 그 위치를 찾으세요.

```text
np.array([[3, 7, 2], [5, 9, 1], [8, 4, 6]])
```

A
```
np.array([[3, 7, 2], [5, 9, 1], [8, 4, 6]]).max()
np.unravel_index(np.array([[3, 7, 2], [5, 9, 1], [8, 4, 6]]).argmax(), (3, 3))
```

### Q10. 아래와 같은 1차원 배열과 2차원 배열이 있습니다. 두 행렬의 곱을 계산하세요.

```text
a = np.array([1, 2, 3, 4])
b = np.array([[2, 0], [1, 3], [3, 1], [0, 2]])
```

A
```
np.dot(np.array([1, 2, 3, 4]), np.array([[2, 0], [1, 3], [3, 1], [0, 2]]))
```

### Q11. 1에서 50까지의 숫자로 구성된 배열이 있습니다. 이 중에서 소수만 추출하세요.

A
```
arr_1_to_50 = np.arange(1, 51)
is_prime = np.array([all(i % j != 0 for j in range(2, int(np.sqrt(i)) + 1)) for i in arr_1_to_50])
arr_1_to_50[is_prime]
```


++ 실행하면서 생긴 python venv 와 poetry 의 차이

Q: python -m venv 명령어를 사용하면, 해당 폴더가 생기잖아?
그런데 poetry 를 사용하면 폴더가 생성되지 않는데, 무슨 차이야?

python -m venv test 를 하면, 의존성 관련 패키지들이 모두 test 폴더에 저장되는거야?
그렇다면 poerty 를 통해 설치한 패키지들은 어디 저장돼?


A
아래는 전체를 마크다운 형식으로 다시 작성한 내용입니다. 이 내용을 .md 파일로 저장하면, 마크다운 형식이 올바르게 적용됩니다.

# Python `venv`와 `Poetry`의 가상환경 차이

---

## 1. `python -m venv` 방식

`python -m venv` 명령어를 사용하면, 지정한 폴더(예: `test`)에 가상환경이 생성됩니다. 이때, 해당 폴더(`test`) 내부에는 Python 실행 파일, 기본 라이브러리, 그리고 나중에 설치할 패키지들이 저장됩니다.

- **폴더 구조**:
  - `bin/` 또는 `Scripts/`: 가상환경 내의 Python 실행 파일 및 스크립트가 저장됨
  - `lib/`: 설치된 패키지들이 저장됨
  - `include/`: C 확장 모듈이 포함된 경우 여기에 관련 파일이 저장됨

즉, `python -m venv test`를 실행하면 `test` 폴더 내에 모든 가상환경 파일 및 의존성 패키지들이 저장됩니다. 모든 패키지는 이 가상환경 내에 로컬로 설치됩니다.

---

## 2. `Poetry` 방식

`Poetry`를 사용하면, 기본적으로 프로젝트 디렉토리 내에 별도의 가상환경 폴더가 보이지 않습니다. 그 이유는 `Poetry`가 **시스템의 표준 가상환경 디렉토리**에 가상환경을 생성하기 때문입니다. 이 표준 가상환경 경로는 운영 체제와 Python 설정에 따라 다를 수 있으며, 보통 아래 경로에 생성됩니다:

- **Windows**: `%APPDATA%\pypoetry\virtualenvs\`
- **Linux/macOS**: `$HOME/.cache/pypoetry/virtualenvs/`

이 경로 내에 프로젝트 이름과 해시값을 사용하여 가상환경 폴더가 자동으로 생성되고, 여기에 의존성 패키지들이 저장됩니다.

---

### 3. `Poetry` 가상환경 위치 확인 및 설정

Poetry가 생성한 가상환경의 경로를 확인하려면 아래 명령어를 사용할 수 있습니다:

```bash
poetry env info --path
```

이 명령어를 통해 현재 프로젝트에 연결된 가상환경의 경로를 확인할 수 있습니다. 만약 가상환경을 프로젝트 내에 두고 싶다면, 다음 명령어로 프로젝트 루트 폴더에 가상환경을 생성할 수 있습니다:

```bash
poetry config virtualenvs.in-project true
poetry install
```


이렇게 설정하면 venv 폴더가 프로젝트 디렉토리 내에 생성되고, 모든 패키지가 이 폴더에 저장됩니다.

### 차이점 정리

| 방식             | `python -m venv`               | `Poetry`                            |
|----------------|--------------------------------|-------------------------------------|
| **가상환경 생성 위치** | 지정한 폴더에 가상환경 폴더 생성 (`test/` 등) | 기본적으로 시스템 표준 경로에 생성                 |
| **패키지 저장 위치**  | 가상환경 폴더 내부 (`lib/` 폴더에 저장)     | 시스템 표준 가상환경 경로 또는 프로젝트 내            |
| **가상환경 확인 방법** | 가상환경 폴더가 명확히 보임                | `poetry env info --path` 명령어로 확인 가능 |
| **프로젝트 내 생성**  | 기본적으로 프로젝트 디렉토리 내에 생성 가능       | 설정을 통해 프로젝트 내에 가상환경 생성 가능           |

따라서 python -m venv는 가상환경을 프로젝트 내에 명확하게 생성하고 관리하는 반면, Poetry는 기본적으로 시스템 경로에 가상환경을 생성하여 관리하지만, 설정을 통해 프로젝트 내에서도 생성이 가능합니다.